use anyhow::Context;
use can_dbc::{ByteOrder, Dbc, ValueType};
use clap::Parser;
use heck::ToSnakeCase;
use std::fs;
use std::io::{self, Write};

#[derive(Parser, Debug)]
#[command(author, version, about)]
struct Args {
    #[arg(short, long)]
    input: String,

    #[arg(short, long, default_value = "myproto")]
    proto_name: String,
}

fn main() -> anyhow::Result<()> {
    let args = Args::parse();

    let contents = fs::read_to_string(&args.input)
        .with_context(|| format!("Failed to read DBC file: {}", args.input))?;
    let dbc = Dbc::try_from(contents.as_str())
        .map_err(|e| anyhow::anyhow!("DBC Parse error: {:?}", e))?;

    generate_lua(&dbc, &args.proto_name, &mut io::stdout())?;
    Ok(())
}

const LUA_HELPERS: &str = r#"
local function extract_can_signal(buffer, start_bit, length, is_little_endian, is_signed)
    if not buffer or buffer:len() == 0 then return nil, nil end
    if length <= 0 then return nil, nil end

    local val = UInt64(0)

    if is_little_endian then
        local start_byte = math.floor(start_bit / 8)
        local end_bit_pos = start_bit + length - 1
        local end_byte = math.floor(end_bit_pos / 8)
        local byte_len = end_byte - start_byte + 1

        if start_byte < 0 then return nil, nil end
        if start_byte + byte_len > buffer:len() then return nil, nil end

        local raw = UInt64(0)
        for i = 0, byte_len - 1 do
            local b = buffer(start_byte + i, 1):uint()
            raw = raw + UInt64(b) * (UInt64(1):lshift(i * 8))
        end

        local shift = start_bit % 8
        val = raw:rshift(shift):band(UInt64(1):lshift(length) - 1)
    else
        -- Motorola format
        local linear_start = (math.floor(start_bit / 8) * 8) + (7 - (start_bit % 8))
        if buffer:len() * 8 >= linear_start + length then
            val = buffer:bitfield(linear_start, length)
            val = UInt64(val)
        else
            return nil, nil
        end
    end

    local raw_u = val:tonumber()
    local raw_s = raw_u

    if is_signed then
        local max_val = UInt64(1):lshift(length)
        local threshold = UInt64(1):lshift(length - 1)
        if val >= threshold then
            raw_s = -((max_val - val):tonumber())
        end
    end

    return raw_u, raw_s
end

local function range_for_bits(tvbuf, start_bit, length)
    if not tvbuf or tvbuf:len() == 0 then return nil end
    if length <= 0 then return nil end

    local start_byte = math.floor(start_bit / 8)
    local end_bit_pos = start_bit + length - 1
    local end_byte = math.floor(end_bit_pos / 8)
    local byte_len = end_byte - start_byte + 1

    if start_byte < 0 then return nil end
    if start_byte + byte_len > tvbuf:len() then return nil end

    return tvbuf(start_byte, byte_len)
end

local function add_with_highlight(subtree, field, tvbuf, start_bit, length, value)
    if type(subtree) ~= "userdata" then return nil end
    local r = range_for_bits(tvbuf, start_bit, length)
    if not r then
        return subtree:add(field, value)
    end
    return subtree:add(field, r, value)
end
"#;

fn generate_lua(dbc: &Dbc, proto_name: &str, out: &mut impl Write) -> io::Result<()> {
    let p_name = proto_name.to_snake_case();

    writeln!(out, "-- Auto-generated by dbc2shark")?;
    writeln!(
        out,
        "local p_{} = Proto(\"{}\", \"CAN Database Dissector\")",
        p_name, p_name
    )?;
    writeln!(out, "{}", LUA_HELPERS)?;
    writeln!(out, "")?;

    writeln!(out, "local f_can_id = Field.new(\"can.id\")")?;
    writeln!(out, "")?;

    for message in &dbc.messages {
        writeln!(
            out,
            "-- {} (0x{:X})",
            message.name,
            message.id.raw() & 0x1FFFFFFF
        )?;
        let msg_name_snake = message.name.to_snake_case();

        for signal in &message.signals {
            let sig_name_snake = signal.name.to_snake_case();
            let full_filter_name = format!("{}.{}.{}", p_name, msg_name_snake, sig_name_snake);
            let var_name = format!("f_{}_{}", msg_name_snake, sig_name_snake);

            let field_type = if is_integer_signal(signal.factor, signal.offset) {
                let is_signed = matches!(signal.value_type, ValueType::Signed);
                match signal.size {
                    1..=8 => {
                        if is_signed {
                            "int8"
                        } else {
                            "uint8"
                        }
                    }
                    9..=16 => {
                        if is_signed {
                            "int16"
                        } else {
                            "uint16"
                        }
                    }
                    17..=24 => {
                        if is_signed {
                            "int24"
                        } else {
                            "uint24"
                        }
                    }
                    25..=32 => {
                        if is_signed {
                            "int32"
                        } else {
                            "uint32"
                        }
                    }
                    33..=64 => {
                        if is_signed {
                            "int64"
                        } else {
                            "uint64"
                        }
                    }
                    _ => "bytes",
                }
            } else {
                "double"
            };

            writeln!(
                out,
                "local {} = ProtoField.{}(\"{}\", \"{}\")",
                var_name, field_type, full_filter_name, signal.name
            )?;
        }
        writeln!(out, "")?;
    }

    writeln!(out, "p_{}.fields = {{", p_name)?;
    for message in &dbc.messages {
        let msg_name_snake = message.name.to_snake_case();
        for signal in &message.signals {
            let sig_name_snake = signal.name.to_snake_case();
            writeln!(out, "    f_{}_{},", msg_name_snake, sig_name_snake)?;
        }
    }
    writeln!(out, "}}")?;
    writeln!(out, "")?;

    writeln!(out, "function p_{}.dissector(tvbuf, pinfo, tree)", p_name)?;

    writeln!(out, "    if type(tree) ~= \"userdata\" then return 0 end")?;
    writeln!(out, "")?;
    writeln!(out, "    local can_id_fi = f_can_id()")?;
    writeln!(out, "    if not can_id_fi then return 0 end")?;
    writeln!(out, "")?;
    writeln!(out, "    local can_id = can_id_fi.value")?;
    writeln!(
        out,
        "    if type(can_id) == \"userdata\" and can_id.tonumber then"
    )?;
    writeln!(out, "        can_id = can_id:tonumber()")?;
    writeln!(out, "    else")?;
    writeln!(out, "        can_id = tonumber(can_id)")?;
    writeln!(out, "    end")?;
    writeln!(out, "    if not can_id then return 0 end")?;
    writeln!(out, "")?;
    writeln!(
        out,
        "    if not tvbuf or tvbuf:len() == 0 then return 0 end"
    )?;
    writeln!(out, "")?;
    writeln!(
        out,
        "    local subtree = tree:add(p_{}, tvbuf(), \"CAN Database Dissector\")",
        p_name
    )?;
    writeln!(
        out,
        "    if type(subtree) ~= \"userdata\" then return 0 end"
    )?;
    writeln!(out, "")?;

    let mut first = true;
    for message in &dbc.messages {
        let id_raw = message.id.raw() & 0x1FFFFFFF;

        if first {
            writeln!(out, "    if can_id == {} then", id_raw)?;
            first = false;
        } else {
            writeln!(out, "    elseif can_id == {} then", id_raw)?;
        }

        writeln!(
            out,
            "        if pinfo and pinfo.cols and pinfo.cols.info then"
        )?;
        writeln!(
            out,
            "            pinfo.cols.info:append(\" [{}]\")",
            message.name
        )?;
        writeln!(out, "        end")?;

        let msg_name_snake = message.name.to_snake_case();
        for signal in &message.signals {
            let sig_name_snake = signal.name.to_snake_case();
            let var_name = format!("f_{}_{}", msg_name_snake, sig_name_snake);

            let is_le = matches!(signal.byte_order, ByteOrder::LittleEndian);
            let is_signed = matches!(signal.value_type, ValueType::Signed);

            writeln!(out, "")?;
            writeln!(
                out,
                "        -- {}: start_bit={} len={} {} {}, factor={}",
                signal.name,
                signal.start_bit,
                signal.size,
                if is_le { "little" } else { "big" },
                if is_signed { "signed" } else { "unsigned" },
                signal.factor
            )?;

            writeln!(out, "        do")?;
            writeln!(
                out,
                "            local raw_u, raw_s = extract_can_signal(tvbuf, {}, {}, {}, {})",
                signal.start_bit, signal.size, is_le, is_signed
            )?;

            writeln!(out, "            if raw_u ~= nil then")?;

            if is_integer_signal(signal.factor, signal.offset) {
                writeln!(
                    out,
                    "                local phys = (raw_s * {}) + {}",
                    signal.factor, signal.offset
                )?;
            } else {
                writeln!(
                    out,
                    "                local phys = (raw_s * {:?}) + {:?}",
                    signal.factor, signal.offset
                )?;
            }

            writeln!(
                out,
                "                add_with_highlight(subtree, {}, tvbuf, {}, {}, phys)",
                var_name, signal.start_bit, signal.size
            )?;

            writeln!(out, "            end")?;
            writeln!(out, "        end")?;
        }
    }

    if !first {
        writeln!(out, "    end")?;
    }

    writeln!(out, "")?;
    writeln!(out, "    return tvbuf:len()")?;
    writeln!(out, "end")?;
    writeln!(out, "")?;

    writeln!(out, "do")?;
    writeln!(
        out,
        "    local ok, can_id_tbl = pcall(DissectorTable.get, \"can.id\")"
    )?;
    writeln!(out, "    if ok and can_id_tbl then")?;
    for message in &dbc.messages {
        let id_raw = message.id.raw() & 0x1FFFFFFF;
        writeln!(
            out,
            "        can_id_tbl:add({}, p_{}) -- {}",
            id_raw, p_name, message.name
        )?;
    }
    writeln!(out, "    else")?;
    writeln!(
        out,
        "        local ok2, decode_tbl = pcall(DissectorTable.get, \"can.subdissector\")"
    )?;
    writeln!(
        out,
        "        if ok2 and decode_tbl and decode_tbl.add_for_decode_as then"
    )?;
    writeln!(
        out,
        "            decode_tbl:add_for_decode_as(p_{})",
        p_name
    )?;
    writeln!(out, "        end")?;
    writeln!(out, "    end")?;
    writeln!(out, "end")?;

    Ok(())
}

fn is_integer_signal(factor: f64, offset: f64) -> bool {
    (factor - 1.0).abs() < f64::EPSILON && offset.abs() < f64::EPSILON
}
